"""
title: Usage Costs Tracking Util - shared module for manifolds
author: Dmitriy Alergant
author_url: https://github.com/DmitriyAlergant-t1a/open-webui-cost-tracking-manifolds
version: 0.1.0
required_open_webui_version: 0.5.0
license: MIT
"""

import json

import time
import asyncio
import sys

from datetime import datetime
from decimal import ROUND_HALF_UP, Decimal, getcontext
from threading import Lock
from typing import Any, Awaitable, Callable
from decimal import Decimal
from datetime import datetime
from sqlalchemy import text
from open_webui.internal.db import get_db, engine



import tiktoken


MODULE_PRICING_DATA = "function_module_usage_tracking_pricing_data"

class Config:
    DATA_DIR = "data"
    USER_COST_FILE = DATA_DIR
    DECIMALS = "0.00000001"
    DEBUG_PREFIX = "DEBUG:    " + __name__ + " -"
    INFO_PREFIX = "INFO:     " + __name__ + " -"
    COMPENSATION = 1.0

class UsagePersistenceManager:
    def __init__(self, debug=False):
        self._init_db()
        self.DEBUG = debug

    def _init_db(self):
        """Initialize database and create table if it doesn't exist"""
        is_sqlite = "sqlite" in engine.url.drivername

        # drop_table_sql = """
        #     DROP TABLE IF EXISTS usage_costs
        # """

        create_table_sql = """
            CREATE TABLE IF NOT EXISTS usage_costs (
                id INTEGER PRIMARY KEY {auto_increment},
                user_id TEXT,
                user_email TEXT,
                model TEXT,
                task TEXT,
                metadata TEXT,
                timestamp TIMESTAMP NOT NULL,
                input_tokens INTEGER,
                output_tokens INTEGER,
                total_cost DECIMAL(20,8),
                display_cost DECIMAL(20,8),
                cost_currency TEXT,
                model_used_by_cost_calculation TEXT,
                web_search_requests INTEGER
            )
        """
        create_table_sql = create_table_sql.format(
            auto_increment=(
                "AUTOINCREMENT" if is_sqlite else "GENERATED BY DEFAULT AS IDENTITY"
            )
        )

        # Add display_cost column if not exists
        if is_sqlite:
            add_display_cost_column_sql = """
                PRAGMA table_info(usage_costs);
            """
            alter_table_sql = """
                ALTER TABLE usage_costs ADD COLUMN display_cost DECIMAL(20,8);
            """
        else:
            # PostgreSQL
            add_display_cost_column_sql = """
                SELECT column_name FROM information_schema.columns 
                WHERE table_name = 'usage_costs' AND column_name = 'display_cost';
            """
            alter_table_sql = """
                ALTER TABLE usage_costs ADD COLUMN IF NOT EXISTS display_cost DECIMAL(20,8);
            """

        # Add web_search_requests column if not exists
        if is_sqlite:
            add_web_search_requests_column_sql = """
                PRAGMA table_info(usage_costs);
            """
            alter_table_add_web_search_sql = """
                ALTER TABLE usage_costs ADD COLUMN web_search_requests INTEGER;
            """
        else:
            # PostgreSQL
            add_web_search_requests_column_sql = """
                SELECT column_name FROM information_schema.columns 
                WHERE table_name = 'usage_costs' AND column_name = 'web_search_requests';
            """
            alter_table_add_web_search_sql = """
                ALTER TABLE usage_costs ADD COLUMN IF NOT EXISTS web_search_requests INTEGER;
            """

        create_index1_sql = """
            CREATE INDEX IF NOT EXISTS idx_user_email ON usage_costs(user_email);
        """

        create_index2_sql = """
            CREATE INDEX IF NOT EXISTS idx_user_id ON usage_costs(user_id);
        """

        # Create usage_costs_by_chat table
        create_chat_costs_table_sql = """
            CREATE TABLE IF NOT EXISTS usage_costs_by_chat (
                chat_id TEXT PRIMARY KEY,
                user_id TEXT,
                user_email TEXT,
                total_cost DECIMAL(20,8),
                display_cost DECIMAL(20,8),
                cost_currency TEXT,
                last_updated TIMESTAMP NOT NULL
            )
        """

        # Add display_cost column to usage_costs_by_chat if not exists
        if is_sqlite:
            add_chat_display_cost_column_sql = """
                PRAGMA table_info(usage_costs_by_chat);
            """
            alter_chat_table_sql = """
                ALTER TABLE usage_costs_by_chat ADD COLUMN display_cost DECIMAL(20,8);
            """
        else:
            # PostgreSQL
            add_chat_display_cost_column_sql = """
                SELECT column_name FROM information_schema.columns 
                WHERE table_name = 'usage_costs_by_chat' AND column_name = 'display_cost';
            """
            alter_chat_table_sql = """
                ALTER TABLE usage_costs_by_chat ADD COLUMN IF NOT EXISTS display_cost DECIMAL(20,8);
            """

        try:
            with get_db() as db:
                # db.execute(text(drop_table_sql))
                db.execute(text(create_table_sql))
                db.execute(text(create_index1_sql))
                db.execute(text(create_index2_sql))
                db.execute(text(create_chat_costs_table_sql))
                
                # Add display_cost column to usage_costs if not exists
                if is_sqlite:
                    columns = db.execute(text(add_display_cost_column_sql)).fetchall()
                    column_names = [column[1] for column in columns]
                    if 'display_cost' not in column_names:
                        db.execute(text(alter_table_sql))
                else:
                    result = db.execute(text(add_display_cost_column_sql)).fetchone()
                    if not result:
                        db.execute(text(alter_table_sql))
                
                # Add web_search_requests column to usage_costs if not exists
                if is_sqlite:
                    columns = db.execute(text(add_web_search_requests_column_sql)).fetchall()
                    column_names = [column[1] for column in columns]
                    if 'web_search_requests' not in column_names:
                        db.execute(text(alter_table_add_web_search_sql))
                else:
                    result = db.execute(text(add_web_search_requests_column_sql)).fetchone()
                    if not result:
                        db.execute(text(alter_table_add_web_search_sql))
                
                # Add display_cost column to usage_costs_by_chat if not exists
                if is_sqlite:
                    columns = db.execute(text(add_chat_display_cost_column_sql)).fetchall()
                    column_names = [column[1] for column in columns]
                    if 'display_cost' not in column_names:
                        db.execute(text(alter_chat_table_sql))
                else:
                    result = db.execute(text(add_chat_display_cost_column_sql)).fetchone()
                    if not result:
                        db.execute(text(alter_chat_table_sql))
                
                db.commit()
        except Exception as e:
            print(f"{Config.INFO_PREFIX} Database error in _init_db: {e}")
            raise

    async def log_usage_fact(
        self,
        user_id: str,
        user_email: str,
        model: str,
        task: str,
        metadata: str,
        input_tokens: int,
        output_tokens: int,
        total_cost: Decimal,
        display_cost: Decimal,
        cost_currency,
        model_used_by_cost_calculation: str,
        web_search_requests: int = 0,
    ):
        """Insert a new cost record into the database"""
        timestamp = datetime.now()

        insert_sql = """
            INSERT INTO usage_costs (
                       user_id, user_email,  model,  task,  metadata, timestamp,  input_tokens,  output_tokens,  total_cost,  display_cost,  cost_currency,  model_used_by_cost_calculation, web_search_requests
            ) VALUES (:user_id, :user_email, :model, :task, :metadata, :timestamp, :input_tokens, :output_tokens, :total_cost, :display_cost, :cost_currency, :model_used_by_cost_calculation, :web_search_requests)
        """

        with get_db() as db:
            try:
                db.execute(
                    text(insert_sql),
                    {
                        "user_id": user_id,
                        "user_email": user_email,
                        "model": model,
                        "task": task,
                        "metadata": metadata,
                        "timestamp": timestamp,
                        "input_tokens": input_tokens,
                        "output_tokens": output_tokens,
                        "total_cost": str(total_cost),
                        "display_cost": str(display_cost),
                        "cost_currency": cost_currency,
                        "model_used_by_cost_calculation": model_used_by_cost_calculation,
                        "web_search_requests": web_search_requests,
                    },
                )
                db.commit()

                if self.DEBUG:
                    print(
                        f"{Config.DEBUG_PREFIX} Persisted usage cost record for user {user_email}, model {model}, task {task}, input tokens {input_tokens}, output_tokens {output_tokens}, total_cost {total_cost}, display_cost {display_cost}, model_used_by_cost_calculation {model_used_by_cost_calculation}, web_search_requests {web_search_requests}"
                    )

            except Exception as e:
                print(f"{Config.INFO_PREFIX} Database error in log_usage_fact: {e}")
                raise

    async def get_chat_total_cost(self, chat_id: str) -> tuple[Decimal, Decimal, str]:
        """Get total cost and display cost for a chat"""
        if not chat_id:
            return Decimal('0'), Decimal('0'), ''

        select_sql = """
            SELECT total_cost, display_cost, cost_currency 
            FROM usage_costs_by_chat 
            WHERE chat_id = :chat_id
        """

        with get_db() as db:
            try:
                result = db.execute(
                    text(select_sql),
                    {"chat_id": chat_id}
                ).fetchone()
                
                if result:
                    # Handle case where display_cost might be NULL in existing records
                    display_cost = Decimal(str(result[1])) if result[1] is not None else Decimal(str(result[0]))
                    return Decimal(str(result[0])), display_cost, result[2]
                return Decimal('0'), Decimal('0'), ''

            except Exception as e:
                print(f"{Config.INFO_PREFIX} Database error in get_chat_total_cost: {e}")
                raise

    async def update_chat_total_cost(
        self,
        chat_id: str,
        user_id: str,
        user_email: str,
        additional_cost: Decimal,
        additional_display_cost: Decimal,
        currency: str
    ):
        """Update total cost and display cost for a chat"""
        if not chat_id:
            return

        timestamp = datetime.now()
        is_sqlite = "sqlite" in engine.url.drivername

        if is_sqlite:
            # SQLite version using ON CONFLICT
            upsert_sql = """
                INSERT INTO usage_costs_by_chat (
                    chat_id, user_id, user_email, total_cost, display_cost, cost_currency, last_updated
                ) VALUES (
                    :chat_id, :user_id, :user_email, :additional_cost, :additional_display_cost, :currency, :timestamp
                )
                ON CONFLICT(chat_id) DO UPDATE SET
                    total_cost = total_cost + :additional_cost,
                    display_cost = COALESCE(display_cost, 0) + :additional_display_cost,
                    cost_currency = :currency,
                    last_updated = :timestamp
            """
        else:
            # PostgreSQL version using ON CONFLICT
            upsert_sql = """
                INSERT INTO usage_costs_by_chat (
                    chat_id, user_id, user_email, total_cost, display_cost, cost_currency, last_updated
                ) VALUES (
                    :chat_id, :user_id, :user_email, :additional_cost, :additional_display_cost, :currency, :timestamp
                )
                ON CONFLICT (chat_id) DO UPDATE SET
                    total_cost = usage_costs_by_chat.total_cost + :additional_cost,
                    display_cost = COALESCE(usage_costs_by_chat.display_cost, 0) + :additional_display_cost,
                    cost_currency = :currency,
                    last_updated = :timestamp
            """

        with get_db() as db:
            try:
                db.execute(
                    text(upsert_sql),
                    {
                        "chat_id": chat_id,
                        "user_id": user_id,
                        "user_email": user_email,
                        "additional_cost": str(additional_cost),
                        "additional_display_cost": str(additional_display_cost),
                        "currency": currency,
                        "timestamp": timestamp
                    }
                )
                db.commit()

                if self.DEBUG:
                    print(f"{Config.DEBUG_PREFIX} Updated chat {chat_id} total cost with additional {additional_cost} (display: {additional_display_cost}) {currency}")

            except Exception as e:
                print(f"{Config.INFO_PREFIX} Database error in update_chat_total_cost: {e}")
                raise


class ModelCostManager:

    def __init__(self, debug:bool = False):
        self.DEBUG = debug
        self.pricing_data = self._load_pricing_data()

    def _load_pricing_data(self):
        pricing_data_module_name = MODULE_PRICING_DATA
        if pricing_data_module_name not in sys.modules:
            raise Exception(f"Module {pricing_data_module_name} is not loaded")
        pricing_data_module = sys.modules[pricing_data_module_name]
        return pricing_data_module.pricing_data

    def _normalize_model_name(self, name: str, strip_prefix: bool = False) -> str:
        name = name.lower()
        
        # Always remove '_manifold' from the prefix if present
        if '_manifold' in name:
            parts = name.split('_manifold', 1)
            name = parts[0] + (parts[1] if len(parts) > 1 else '')
        
        if strip_prefix:
            if "." in name:
                name = name.split(".", 1)[1]
            if "/" in name:
                name = name.split("/", 1)[1]
        
        return name

    def _find_best_match(self, query: str, strip_prefix: bool = False) -> str:

        normalized_query = self._normalize_model_name(query, strip_prefix)

        best_match = None
        longest_match_length = 0

        for key in self.pricing_data.keys():
            
            if normalized_query.startswith(key):

                match_length = len(key)
                if match_length > longest_match_length:
                    longest_match_length = match_length
                    best_match = key

        print (f"{Config.DEBUG_PREFIX} _find_best_match: normalized_query: {normalized_query}, best_match: {best_match}")

        return best_match

    def get_model_data(self, model):
        model = model.lower().strip()

        if model in self.pricing_data:
            if self.DEBUG:
                print(
                    f"{Config.DEBUG_PREFIX} Using model pricing data for '{model}' (exact match)"
                )
            return model, self.pricing_data[model]
        else:
            if self.DEBUG:
                print(
                    f"{Config.DEBUG_PREFIX} Searching best pricing data match for model named '{model}'"
                )

            best_match = self._find_best_match(model, strip_prefix=False)

            if best_match is None:
                print(
                    f"{Config.DEBUG_PREFIX} No pricing data match for full model name {model}. Trying without provider prefix: '{self._normalize_model_name(model, True)}'"
                )
                best_match = self._find_best_match(model, strip_prefix=True)

            if best_match is None:
                print(
                    f"{Config.DEBUG_PREFIX} Model pricing data not found for model named '{model}'"
                )
                return "unknown", {}

            if self.DEBUG:
                print(
                    f"{Config.DEBUG_PREFIX} Using model pricing data for '{best_match}'"
                )

            return best_match, self.pricing_data.get(best_match, {})


class CostCalculationManager:

    def __init__(self, model: str, model_cost_manager: ModelCostManager, debug:bool = False):

        self.model = model

        self.model_cost_manager = model_cost_manager

        self.DEBUG = debug

        # Establish model pricing data
        (self.model_used_by_cost_calculation, self.model_pricing_data) = (
            model_cost_manager.get_model_data(model)
        )

        # Load tiktoken encoding
        self.enc = self.get_encoding(model)

    def calculate_costs(self, input_tokens: int, output_tokens: int, web_search_requests_count: int = 0) -> tuple[Decimal, Decimal, str, str]:
        """
        Calculate both real costs and display costs
        Returns: (total_cost, total_display_cost, cost_currency, model_used_by_cost_calculation)
        """

        if self.DEBUG:
            print(f"{Config.DEBUG_PREFIX} CostCalculationManager.calculate_costs called with: input_tokens={input_tokens}, output_tokens={output_tokens}, web_search_requests_count={web_search_requests_count}")
            print(f"{Config.DEBUG_PREFIX} Model pricing data for {self.model_used_by_cost_calculation}: {self.model_pricing_data}")

        compensation = Config.COMPENSATION

        if not self.model_pricing_data:
            print(
                f"{Config.INFO_PREFIX} Model '{self.model}' not found in costs json file!"
            )

        getcontext().prec = 10

        # Calculate real costs
        input_cost_per_token = Decimal(
            self.model_pricing_data.get("input_cost_per_token", 0)
        ) / Decimal(self.model_pricing_data.get("token_units", 1))

        output_cost_per_token = Decimal(
            self.model_pricing_data.get("output_cost_per_token", 0)
        ) / Decimal(self.model_pricing_data.get("token_units", 1))

        # Calculate display costs
        input_display_cost_per_token = Decimal(
            self.model_pricing_data.get("input_display_cost_per_token", 
                                       self.model_pricing_data.get("input_cost_per_token", 0))
        ) / Decimal(self.model_pricing_data.get("token_units", 1))

        output_display_cost_per_token = Decimal(
            self.model_pricing_data.get("output_display_cost_per_token", 
                                       self.model_pricing_data.get("output_cost_per_token", 0))
        ) / Decimal(self.model_pricing_data.get("token_units", 1))

        # Calculate cost for web searches
        web_search_cost_per_request = Decimal(self.model_pricing_data.get("web_search_request_cost", 0))
        total_web_search_cost = web_search_requests_count * web_search_cost_per_request
        
        # Use specific display cost for web search if available, otherwise fallback to real cost
        web_search_display_cost_per_request = Decimal(
            self.model_pricing_data.get("web_search_request_display_cost", 
                                       self.model_pricing_data.get("web_search_request_cost", 0)) # Fallback to real cost
        )
        total_web_search_display_cost = web_search_requests_count * web_search_display_cost_per_request

        # Calculate real total cost
        input_cost = input_tokens * input_cost_per_token if input_tokens else 0
        output_cost = output_tokens * output_cost_per_token if output_tokens else 0
        total_cost = Decimal(float(compensation)) * (input_cost + output_cost + total_web_search_cost)
        total_cost = total_cost.quantize(
            Decimal(Config.DECIMALS), rounding=ROUND_HALF_UP
        )

        # Calculate display total cost
        input_display_cost = input_tokens * input_display_cost_per_token if input_tokens else 0
        output_display_cost = output_tokens * output_display_cost_per_token if output_tokens else 0
        total_display_cost = Decimal(float(compensation)) * (input_display_cost + output_display_cost + total_web_search_display_cost)
        total_display_cost = total_display_cost.quantize(
            Decimal(Config.DECIMALS), rounding=ROUND_HALF_UP
        )

        if self.DEBUG:
            print(
                f"{Config.DEBUG_PREFIX} Calculated costs: real={total_cost} (tokens: {input_cost + output_cost}, search: {total_web_search_cost}), display={total_display_cost} (tokens: {input_display_cost + output_display_cost}, search: {total_web_search_display_cost}), currency={self.model_pricing_data.get('cost_currency', '')}"
            )

        return (
            total_cost,
            total_display_cost,
            self.model_pricing_data.get("cost_currency", ""),
            self.model_used_by_cost_calculation,
        )

    def get_encoding(self, model):

        if "." in model:
            model = model.split(".", 1)[1]

        try:
            enc = tiktoken.encoding_for_model(model)

            if self.DEBUG:
                print(
                    f"{Config.DEBUG_PREFIX} Tiktoken encoding found for model {model}, loaded"
                )

            return enc
        except KeyError:
            if self.DEBUG:
                print(
                    f"{Config.DEBUG_PREFIX} Encoding for model {model} not found. Using cl100k_base for computing tokens."
                )
            return tiktoken.get_encoding("cl100k_base")

    def count_tokens(self, message_content: str) -> int:
        output_tokens = len(self.enc.encode(message_content))
        return output_tokens


class CostTrackingManager:

    def __init__(self, model: str, __user__: dict, __metadata__: dict, task: str, debug: bool = False):
        self.model = model
        self.__user__ = __user__
        self.__metadata__ = __metadata__
        self.task = task

        self.DEBUG = debug

        self.model_cost_manager = ModelCostManager (debug=debug)

        self.cost_calculation_manager = CostCalculationManager(model=model, model_cost_manager=self.model_cost_manager, debug=debug)

        self.usage_persistence_manager = UsagePersistenceManager(debug=debug)

        self.chat_id = self.__metadata__.get("chat_id")
        self.session_id = self.__metadata__.get("session_id")
        
        # Use session_id as chat_id for local chats
        if self.chat_id == 'local' and self.session_id:
            self.chat_id = self.session_id
        
        self.chat_total_cost = Decimal('0')
        self.chat_display_cost = Decimal('0')
        self.chat_currency = ''
        self._chat_cost_loaded = False
        
        # Load initial chat cost if chat_id exists
        if self.chat_id:
            asyncio.create_task(self._load_chat_cost())

    async def _load_chat_cost(self):
        """Load existing chat cost"""
        if self.chat_id == 'local':
            self.chat_total_cost = Decimal('0')
            self.chat_display_cost = Decimal('0')
            self.chat_currency = ''
            self._chat_cost_loaded = True
            return
        
        self.chat_total_cost, self.chat_display_cost, self.chat_currency = await self.usage_persistence_manager.get_chat_total_cost(self.chat_id)
        self._chat_cost_loaded = True
        
        if self.DEBUG:
            print(f"{Config.DEBUG_PREFIX} Loaded chat {self.chat_id} total cost: {self.chat_total_cost} (display: {self.chat_display_cost}) {self.chat_currency}")

    async def update_status_message(
        self,
        input_tokens,
        generated_tokens,
        reasoning_tokens,
        start_time,
        __event_emitter__,
        current_cost,
        current_display_cost,
        cost_currency,
        status,
        context_messages_count=0,
        web_search_requests_count: int = 0
    ):
        # Skip status emission if task is not null
        if self.task:
            return

        current_time = time.time()
        processing_time = current_time - start_time
        is_final = status in ("Completed", "Stopped", "")

        if __event_emitter__ is None:
            if self.DEBUG:
                print(
                    f"{Config.DEBUG_PREFIX} __event_emitter__ is None. Not sending status update event"
                )
            return

        cost_str = ""
        if current_display_cost is not None and cost_currency is not None:
            # Format current request cost with + for in-progress
            request_cost_str = (
                f"{current_display_cost:,.2f}₽{'' if is_final else '+'}"
                if cost_currency == "RUB"
                else f"${current_display_cost:,.2f}{'' if is_final else '+'}"
            )
            
            # For local chat_id, only show current request cost
            if self.chat_id == 'local':
                cost_str = f"Cost: {request_cost_str}"
            else:
                # Show both chat total and current request costs if chat cost is loaded
                cost_str = f"This request: {request_cost_str}"

                if self._chat_cost_loaded:
                    total_display_cost = self.chat_display_cost + current_display_cost
                    total_cost_str = (
                        f"{total_display_cost:,.2f}₽{'' if is_final else '+'}"
                        if cost_currency == "RUB"
                        else f"${total_display_cost:,.2f}{'' if is_final else '+'}"
                    )
                    cost_str += f" | Chat total: {total_cost_str}"

            # Add warning about starting new chat if conditions are met
            if self.chat_id != 'local' and input_tokens >= 20000 and context_messages_count >= 20:
                cost_str += " | Consider starting a new chat"

        # Token information varies based on final status
        token_parts = []
        if input_tokens is not None:
            token_parts.append(f"{input_tokens} input tokens")

        if generated_tokens:
            if reasoning_tokens:
                token_parts.append(f"{generated_tokens} output tokens (incl. {reasoning_tokens} reasoning)")
            else:
                token_parts.append(f"{generated_tokens} output tokens")

        if web_search_requests_count > 0:
            search_plural = "s" if web_search_requests_count > 1 else ""
            token_parts.append(f"{web_search_requests_count} web search{search_plural}")

        token_str = " | ".join(token_parts) if token_parts else ""

        status_parts = [
            f"{processing_time:.2f}s" if (start_time and  status in ("Completed", "Stopped")) else "",
            token_str if token_str else "",
            f"{cost_str}" if cost_str else "",
            status if status else "",
        ]

        status_message = " | ".join(filter(None, status_parts))

        # Only emit event if status is initial or final
        should_emit = status in ("Requested...", "Completed", "Stopped", "")

        if should_emit:
            await __event_emitter__(
                {
                    "type": "status",
                    "data": {
                        "description": status_message,
                        "done": is_final,
                    },
                }
            )

        if self.DEBUG:
            print(f"{Config.DEBUG_PREFIX} status string update (emitted: {should_emit}): {status_message}")

    def count_tokens(self, message_content: str) -> int:
        return self.cost_calculation_manager.count_tokens(message_content)

    def calculate_costs_update_status_and_persist(
        self,
        input_tokens: int,
        generated_tokens: int,
        reasoning_tokens: int,
        start_time: time,
        __event_emitter__: Callable[[Any], Awaitable[None]],
        status: str,
        persist_usage: bool,
        context_messages_count: int = 0,
        web_search_requests_count: int = 0,
    ):
        # Calculate Costs
        total_cost, total_display_cost, cost_currency, model_used_by_cost_calculation = (
            self.cost_calculation_manager.calculate_costs(
                input_tokens=input_tokens,
                output_tokens=generated_tokens,
                web_search_requests_count=web_search_requests_count,
            )
        )

        # Send visual status message update event
        asyncio.create_task(
            self.update_status_message(
                input_tokens,
                generated_tokens,
                reasoning_tokens,
                start_time,
                __event_emitter__,
                total_cost,
                total_display_cost,
                cost_currency,
                status,
                context_messages_count=context_messages_count,
                web_search_requests_count=web_search_requests_count
            )
        )

        if persist_usage:
            async def persist_costs():
                try:
                    # Update chat total cost if this is a chat
                    if self.chat_id:
                        await self.usage_persistence_manager.update_chat_total_cost(
                            chat_id=self.chat_id,
                            user_id=self.__user__["id"],
                            user_email=self.__user__["email"],
                            additional_cost=total_cost,
                            additional_display_cost=total_display_cost,
                            currency=cost_currency
                        )
                        # Only update local total after successful DB update
                        self.chat_total_cost += total_cost
                        self.chat_display_cost += total_display_cost
                        self.chat_currency = cost_currency

                    # Existing usage logging with enhanced metadata
                    metadata_dict = {
                        "chat_id": self.__metadata__.get("chat_id"),
                        "session_id": self.__metadata__.get("session_id"),
                        "context_messages_count": context_messages_count,
                        "web_search_requests_count": web_search_requests_count,
                    }
                    
                    await self.usage_persistence_manager.log_usage_fact(
                        user_id=self.__user__["id"],
                        user_email=self.__user__["email"],
                        metadata=json.dumps(metadata_dict),
                        model=self.model,
                        task=self.task,
                        input_tokens=input_tokens,
                        output_tokens=generated_tokens,
                        total_cost=total_cost,
                        display_cost=total_display_cost,
                        cost_currency=cost_currency,
                        model_used_by_cost_calculation=model_used_by_cost_calculation,
                        web_search_requests=web_search_requests_count,
                    )
                except Exception as e:
                    print(f"{Config.INFO_PREFIX} Error persisting costs: {e}")
                    raise

            # Launch persistence as a task
            asyncio.create_task(persist_costs())


# For OpenWebUI to accept this as a Function Module, there has to be a Filter or Pipe or Action class
class Pipe:
    def __init__(self):
        self.type = "manifold"
        self.id = "usage-tracking-util"
        self.name = "Usage Tracking Util"
        
        pass

    def pipes(self) -> list[dict]:
        return []
